package convex.sampling;

import convex.objects.ConvexBody;
import exceptions.PointOutsideConvexBodyException;
import exceptions.IncompatibleDimensionsException;
import linalg.Matrix;
import linalg.Vector;

/**
 * This class is a general interface for Random Walking methods over convex bodies. Most of sampling and volume computation
 * algorithms in the literature are based on random walking methods.
 *
 * In a random walk, we suppose we are given an initial point \(X_0\) inside the convex body K, and we proceed to generate
 * a chain of interior points \(\{ X_1, X_2, \ldots \}\). These points are generated by repeated application of a non-deterministic
 * function called step(), that is, \( X_{t+1} = step(X_t) \). As we can see, it defines a Markov Chain over the convex body.
 *
 * Our RandomWalk modules provide two main pieces of functionality. First there is the chain length C, which is a upper bound
 * on the size of every chain it samples. Second, there is the sample size S, representing how many points to sample.
 *
 * @see ConvexBody
 * @author lucianodp
 */
abstract class RandomWalk{
    private int chainLength, sampleSize;

    /**
     * Creates a new random walking sampler by specifying two parameters: the maximum chain length (when to stop sampling
     * new points) and how many samples to retrieve from the uniform method.
     * @param chainLength: size of chain
     * @param sampleSize: size of uniform sample
     * @throws IllegalArgumentException if chainLength or sampleSize are non-positive integers
     */
    public RandomWalk(int chainLength, int sampleSize){
        checkParameters(chainLength, sampleSize);
        this.chainLength = chainLength;
        this.sampleSize = sampleSize;
    }

    private void checkParameters(int chainLength, int sampleSize){
        if (chainLength <= 0)
            throw new IllegalArgumentException("Chain length must be a positive integer");

        if (sampleSize <= 0)
            throw new IllegalArgumentException("Sample size must be a positive integer");
    }

    /**
     * Samples a markov chain from a given convexbody
     * @param convexBody: convex body to sample from
     * @param initialPoint: initial point INSIDE the convexbody (starting point for the algorithm)
     * @return Matrix whose every line \(i\) contains the sample \( X_i \).
     * @throws IncompatibleDimensionsException if initialPoint and convexBody have different dimensions
     * @throws PointOutsideConvexBodyException if initialPoint is not on the interior of convex body
     */
    public Matrix chain(ConvexBody convexBody, Vector initialPoint){
        checkInitialPoint(convexBody, initialPoint);
        Vector sample = initialPoint;

        double[][] chain = new double[chainLength+1][initialPoint.getDim()];
        chain[0] = initialPoint.asArray();

        for (int i=1; i <= chainLength; i++) {
            sample = step(convexBody, sample);
            chain[i] = sample.asArray();
        }

        return Matrix.FACTORY.makeMatrix(chain);
    }

    /**
     * The same initial point is used for computing each sample. Although this creates a between samples, for long enough
     * chains this effect should be minimal.
     * @param convexBody: convex body to sample from
     * @param initialPoint: initial point INSIDE the convexbody (starting point for the algorithm).
     * @return matrix whose line \(i\) contains the i-th sample.
     * @throws IncompatibleDimensionsException if initialPoint and convexBody have different dimensions
     * @throws exceptions.IncompatibleDimensionsException if initialPoint and convexBody have different dimensions
     */
    public Matrix uniform(ConvexBody convexBody, Vector initialPoint){
        checkInitialPoint(convexBody, initialPoint);

        double[][] sample = new double[sampleSize][initialPoint.getDim()];

        for (int i=0; i < sampleSize; i++)
            sample[i] = sampleSinglePoint(convexBody, initialPoint).asArray();

        return Matrix.FACTORY.makeMatrix(sample);
    }

    private Vector sampleSinglePoint(ConvexBody convexBody, Vector initialPoint){
        Vector sample = initialPoint;

        for (int i=0; i < chainLength; i++)
            sample = step(convexBody, initialPoint);

        return sample;
    }

    private void checkInitialPoint(ConvexBody convexBody, Vector initialPoint){
        convexBody.checkDim(initialPoint);

        if (!convexBody.isInside(initialPoint))
            throw new PointOutsideConvexBodyException();
    }

    /**
     * Main function of Random Sampling module. At every iteration, we apply this step() function to the previous found point.
     * We note this function is not deterministic, returning different results when applied twice for the same input.
     * @param convexBody: convex body from which we are sampling from
     * @param point: current point in the algorithm (\(X_t\) at iteration t+1)
     * @return next point in the algorithm (\( X_{t+1} \) at the end of iteration t+1)
     */
    abstract Vector step(ConvexBody convexBody, Vector point);
}

